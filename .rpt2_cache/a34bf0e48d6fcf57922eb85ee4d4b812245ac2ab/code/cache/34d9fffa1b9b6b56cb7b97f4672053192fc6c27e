{"code":"import IObject from \"./IObject\";\r\nexport default class IString {\r\n    static charAt(str, index) {\r\n        return str.charAt(index);\r\n    }\r\n    static contains(str, sbustr) {\r\n        return this.indexOf(str, sbustr) != -1;\r\n    }\r\n    static endWith(source, suffix) {\r\n        return RegExp(suffix + \"$\").test(source);\r\n    }\r\n    static format(str, context) {\r\n        if (!context) {\r\n            context = window;\r\n        }\r\n        let replacer = function (str, match) {\r\n            let replacement, subs = match.split(/\\.+/);\r\n            for (let i = 0, len = subs.length; i < len; i++) {\r\n                if (i == 0) {\r\n                    replacement = context;\r\n                }\r\n                if (replacement === undefined) {\r\n                    break;\r\n                }\r\n                replacement = replacement[subs[i]];\r\n            }\r\n            if (typeof replacement == 'undefined') {\r\n                return 'undefined';\r\n            }\r\n            else {\r\n                return replacement;\r\n            }\r\n        };\r\n        return str.replace(/\\{\\{([\\w.]+?)\\}\\}/g, replacer);\r\n    }\r\n    static indexOf(str, substr, index = 0) {\r\n        return str.indexOf(substr, index);\r\n    }\r\n    static isBlank(str) {\r\n        return !str || this.trim(str) === \"\";\r\n    }\r\n    static isEmpty(str) {\r\n        return !str || str === \"\";\r\n    }\r\n    static isNotBlank(str) {\r\n        return !this.isBlank(str);\r\n    }\r\n    static isNotEmpty(str) {\r\n        return !this.isEmpty(str);\r\n    }\r\n    static isNotNullOrEmpty(str) {\r\n        return !this.isNullOrEmpty(str);\r\n    }\r\n    static isNullOrEmpty(str) {\r\n        return IObject.isUndefined(str) || str == \"\";\r\n    }\r\n    static isString(str) {\r\n        return Object.prototype.toString.call(str) === '[object String]';\r\n    }\r\n    static lastIndexOf(str, substr, index = str.length) {\r\n        return str.lastIndexOf(substr, index);\r\n    }\r\n    static padLeft(str, size, padStr = \" \") {\r\n        if (str.length >= size) {\r\n            return str;\r\n        }\r\n        if (!padStr) {\r\n            padStr = \" \";\r\n        }\r\n        let paddingString = new String(), len = Math.floor((size - str.length) / padStr.length), gap = size - (len * padStr.length) - str.length;\r\n        for (let i = 0; i < len; i++) {\r\n            paddingString += padStr;\r\n        }\r\n        paddingString += this.substr(padStr, 0, gap);\r\n        return paddingString + str;\r\n    }\r\n    static padRight(str, size, padStr = \"\") {\r\n        if (str.length >= size) {\r\n            return str;\r\n        }\r\n        if (!padStr) {\r\n            padStr = \" \";\r\n        }\r\n        let paddingString = new String(), len = Math.floor((size - str.length) / padStr.length), gap = size - (len * padStr.length) - str.length;\r\n        for (let i = 0; i < len; i++) {\r\n            paddingString += padStr;\r\n        }\r\n        paddingString += this.substr(padStr, 0, gap);\r\n        return str + paddingString;\r\n    }\r\n    static replace(str, rule, replacement) {\r\n        return str.replace(rule, replacement);\r\n    }\r\n    static replaceFirst(str, rule, replacement) {\r\n        return str.replace(rule, replacement);\r\n    }\r\n    static replaceAll(str, findText, replaceText) {\r\n        return str.replace(new RegExp(findText, \"g\"), replaceText);\r\n    }\r\n    static split(str, separator) {\r\n        return str.split(separator);\r\n    }\r\n    static startWith(source, prefix) {\r\n        return new RegExp(\"^\" + prefix).test(source);\r\n    }\r\n    static stripHTML(source) {\r\n        return String(source || '').replace(/<[^>]+>/g, '');\r\n    }\r\n    static substr(str, start, length = str.length) {\r\n        if (start < 0) {\r\n            start = str.length + start;\r\n        }\r\n        return str.substr(start, length);\r\n    }\r\n    static substring(str, start, stop = str.length) {\r\n        return str.substring(start, stop);\r\n    }\r\n    static toCamelCase(source) {\r\n        if (source.indexOf('-') < 0 && source.indexOf('_') < 0) {\r\n            return source;\r\n        }\r\n        return source.replace(/[-_][^-_]/g, function (match) {\r\n            return match.charAt(1).toUpperCase();\r\n        });\r\n    }\r\n    static toJson(str) {\r\n        return '\"' + str.replace(_CharToReplace, function (a) {\r\n            let c = _Meta[a];\r\n            return IString.isString(c) ? c : '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\r\n        }) + '\"';\r\n    }\r\n    static toLowerCase(str) {\r\n        return str.toLowerCase();\r\n    }\r\n    static toString(str) {\r\n        return str.toString();\r\n    }\r\n    static toUpperCase(str) {\r\n        return str.toUpperCase();\r\n    }\r\n    static trim(str) {\r\n        return str.replace(/^(\\s|\\u3000|\\xa0|\\u00A0)+/, '').replace(/(\\s||\\u3000|\\xa0\\u00A0)+$/, '');\r\n    }\r\n    static trimAll(str) {\r\n        return str.replace(/\\s|\\u3000|\\xa0|\\u00A0/g, \"\");\r\n    }\r\n    static trimLeft(str) {\r\n        return str.replace(/^(\\s|\\u3000|\\xa0\\u00A0)+/, '');\r\n    }\r\n    static trimRight(str) {\r\n        return str.replace(/(\\s|\\u3000|\\xa0\\u00A0)+$/, '');\r\n    }\r\n    static valueOf(str) {\r\n        return str + '';\r\n    }\r\n}\r\nconst _CharToReplace = /[\\\\\\\"\\x00-\\x1f\\x7f-\\uffff]/g;\r\nconst _Meta = {\r\n    \"\\b\": '\\\\b',\r\n    \"\\t\": '\\\\t',\r\n    \"\\n\": '\\\\n',\r\n    \"\\f\": '\\\\f',\r\n    \"\\r\": '\\\\r',\r\n    '\"': '\\\\\"',\r\n    \"\\\\\": '\\\\\\\\',\r\n    '\\v': '\\\\u000b'\r\n};\r\n","dts":{"name":"D:/work/jsdk-lang/dist/typings/IString.d.ts","text":"export default class IString {\r\n    static charAt(str: string, index: number): string;\r\n    static contains(str: string, sbustr: string): boolean;\r\n    static endWith(source: string, suffix: string): boolean;\r\n    static format(str: string, context?: object): string;\r\n    static indexOf(str: string, substr: string, index?: number): number;\r\n    static isBlank(str: string): boolean;\r\n    static isEmpty(str: string): boolean;\r\n    static isNotBlank(str: string): boolean;\r\n    static isNotEmpty(str: string): boolean;\r\n    static isNotNullOrEmpty(str: string): boolean;\r\n    static isNullOrEmpty(str: string): boolean;\r\n    static isString(str: any): boolean;\r\n    static lastIndexOf(str: string, substr: string, index?: number): number;\r\n    static padLeft(str: string, size: number, padStr?: string): string | null;\r\n    static padRight(str: string, size: number, padStr?: string): string | null;\r\n    static replace(str: string, rule: string | RegExp, replacement: string): string;\r\n    static replaceFirst(str: string, rule: string | RegExp, replacement: string): string;\r\n    static replaceAll(str: string, findText: string, replaceText: string): string;\r\n    static split(str: string, separator: string): string[];\r\n    static startWith(source: string, prefix: string): boolean;\r\n    static stripHTML(source: string): string;\r\n    static substr(str: string, start: number, length?: number): string;\r\n    static substring(str: string, start: number, stop?: number): string;\r\n    static toCamelCase(source: string): string;\r\n    static toJson(str: string): string;\r\n    static toLowerCase(str: string): string;\r\n    static toString(str: string): string;\r\n    static toUpperCase(str: string): string;\r\n    static trim(str: string): string;\r\n    static trimAll(str: string): string;\r\n    static trimLeft(str: string): string;\r\n    static trimRight(str: string): string;\r\n    static valueOf(str: any): string;\r\n}\r\n"}}
