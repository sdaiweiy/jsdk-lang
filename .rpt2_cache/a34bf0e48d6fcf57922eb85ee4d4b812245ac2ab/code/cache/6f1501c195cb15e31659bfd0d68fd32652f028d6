{"code":"import IArray from './IArray';\r\nimport IDate from './IDate';\r\nimport IString from './IString';\r\nimport IBoolean from \"./IBoolean\";\r\nimport IFunction from \"./IFunction\";\r\nimport INumber from \"./INumber\";\r\nexport default class IObject {\r\n    static isDefined(object) {\r\n        return !this.isUndefined(object);\r\n    }\r\n    static isUndefined(object) {\r\n        return object == undefined;\r\n    }\r\n    static isObject(object) {\r\n        return 'function' == typeof object || !!(object && 'object' == typeof object);\r\n    }\r\n    static isPlain(object) {\r\n        if (!IObject.isObject(object)) {\r\n            return false;\r\n        }\r\n        if (object.constructor &&\r\n            !this.hasOwn.call(object, \"constructor\") &&\r\n            !this.hasOwn.call(object.constructor.prototype, \"isPrototypeOf\")) {\r\n            return false;\r\n        }\r\n        for (let _name in object) {\r\n            return false;\r\n        }\r\n        if (object.item && typeof object.length == \"number\") {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    static equals(source, target) {\r\n        return deepEquals(source, target);\r\n    }\r\n    static extend(target, ...source) {\r\n        target = target || {};\r\n        for (let i = 0; i < source.length; i++) {\r\n            let obj = source[i];\r\n            if (!obj)\r\n                continue;\r\n            for (let key in source[i]) {\r\n                if (source[i].hasOwnProperty(key)) {\r\n                    target[key] = source[i][key];\r\n                }\r\n            }\r\n        }\r\n        return target;\r\n    }\r\n    static deepExtend(target, ...source) {\r\n        target = target || {};\r\n        for (let i = 0; i < source.length; i++) {\r\n            let obj = source[i];\r\n            if (!obj)\r\n                continue;\r\n            for (let key in obj) {\r\n                if (obj.hasOwnProperty(key)) {\r\n                    if (this.isObject(obj[key])) {\r\n                        target[key] = this.deepExtend(target[key], obj[key]);\r\n                    }\r\n                    else {\r\n                        target[key] = obj[key];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return target;\r\n    }\r\n    static clone(object) {\r\n        return this.deepExtend({}, object);\r\n    }\r\n    static keys(object) {\r\n        if (this.hasOwn.call(Object, \"keys\")) {\r\n            return Object.keys(object);\r\n        }\r\n        let keys = [];\r\n        for (let key in object) {\r\n            if (this.hasOwn.call(object, key)) {\r\n                keys.push(key);\r\n            }\r\n        }\r\n        return keys;\r\n    }\r\n    static values(object) {\r\n        let values = [], keys = this.keys(object);\r\n        for (let i = 0, len = keys.length; i < len; i++) {\r\n            values.push(object[keys[i]]);\r\n        }\r\n        return values;\r\n    }\r\n    static hasKey(object, key) {\r\n        return object != null && this.hasOwn.call(object, key);\r\n    }\r\n    static each(object, fn) {\r\n        IArray.each(this.keys(object), function (i, key) {\r\n            return fn.call(object, key, object[key], object);\r\n        });\r\n    }\r\n    static toJson(object) {\r\n        if (JSON && JSON.stringify) {\r\n            return JSON.stringify(object);\r\n        }\r\n        if (this.isUndefined(object) || IFunction.isFunction(object)) {\r\n            return null;\r\n        }\r\n        else if (IBoolean.isBoolean(object)) {\r\n            return IBoolean.toJson(object);\r\n        }\r\n        else if (IString.isString(object)) {\r\n            return IString.toJson(object);\r\n        }\r\n        else if (IArray.isArray(object)) {\r\n            return IArray.toJson(object);\r\n        }\r\n        else if (INumber.isNumber(object)) {\r\n            return INumber.toJson(object);\r\n        }\r\n        else if (IDate.isDate(object)) {\r\n            return IDate.toJson(object);\r\n        }\r\n        else if (IObject.isObject(object)) {\r\n            let array = [\"{\", \"\"];\r\n            IObject.each(object, function (i, key, value) {\r\n                if (object.hasOwnProperty(key)) {\r\n                    if (!IFunction.isFunction(value) && value !== undefined) {\r\n                        array.push(IObject.toJson(i), \":\", IObject.toJson(value), ',');\r\n                    }\r\n                }\r\n            });\r\n            array[array.length - 1] = '}';\r\n            return array.join(\"\");\r\n        }\r\n        else if (object.toJson) {\r\n            return object.toJson();\r\n        }\r\n        return '';\r\n    }\r\n    static parseJson(data) {\r\n        try {\r\n            if (JSON && JSON.parse) {\r\n                return JSON.parse(data);\r\n            }\r\n            return (new Function(\"return \" + data))();\r\n        }\r\n        catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n}\r\nIObject.hasOwn = Object.prototype.hasOwnProperty;\r\nconst deepEquals = function (a, b, aStack = [], bStack = []) {\r\n    if (a === b) {\r\n        return true;\r\n    }\r\n    if (a == null || b == null) {\r\n        return false;\r\n    }\r\n    if (a !== a) {\r\n        return b !== b;\r\n    }\r\n    let type = typeof a;\r\n    if (type !== 'function' && type !== 'object' && typeof b != 'object') {\r\n        return false;\r\n    }\r\n    let toString = Object.prototype.toString;\r\n    let className = toString.call(a);\r\n    if (className !== toString.call(b)) {\r\n        return false;\r\n    }\r\n    switch (className) {\r\n        case '[object RegExp]':\r\n        case '[object String]':\r\n            return '' + a === '' + b;\r\n        case '[object Number]':\r\n            if (+a !== +a) {\r\n                return +b !== +b;\r\n            }\r\n            return +a === +b;\r\n        case '[object Date]':\r\n        case '[object Boolean]':\r\n            return +a === +b;\r\n    }\r\n    let areArrays = className === '[object Array]';\r\n    if (!areArrays) {\r\n        if (typeof a != 'object' || typeof b != 'object') {\r\n            return false;\r\n        }\r\n        let aCtor = a.constructor, bCtor = b.constructor;\r\n        if (aCtor !== bCtor && !(IFunction.isFunction(aCtor) && aCtor instanceof aCtor &&\r\n            IFunction.isFunction(bCtor) && bCtor instanceof bCtor)\r\n            && ('constructor' in a && 'constructor' in b)) {\r\n            return false;\r\n        }\r\n    }\r\n    let length = aStack.length;\r\n    while (length--) {\r\n        if (aStack[length] === a) {\r\n            return bStack[length] === b;\r\n        }\r\n    }\r\n    if (areArrays) {\r\n        length = a.length;\r\n        if (length !== b.length) {\r\n            return false;\r\n        }\r\n        while (length--) {\r\n            if (!deepEquals(a[length], b[length], aStack, bStack)) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        let keys = IObject.keys(a), key = void 0;\r\n        length = keys.length;\r\n        if (IObject.keys(b).length !== length) {\r\n            return false;\r\n        }\r\n        while (length--) {\r\n            key = keys[length];\r\n            if (!(IObject.hasKey(b, key) && deepEquals(a[key], b[key], aStack, bStack))) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    aStack.pop();\r\n    bStack.pop();\r\n    return true;\r\n};\r\n","dts":{"name":"D:/work/jsdk-lang/dist/typings/IObject.d.ts","text":"export default class IObject {\r\n    private static hasOwn;\r\n    static isDefined(object: any): boolean;\r\n    static isUndefined(object: any): boolean;\r\n    static isObject(object: any): boolean;\r\n    static isPlain(object: any): boolean;\r\n    static equals(source: any, target: any): boolean;\r\n    static extend(target: object, ...source: object[]): any;\r\n    static deepExtend(target: any, ...source: any[]): any;\r\n    static clone<T>(object: T): T;\r\n    static keys(object: object): string[];\r\n    static values(object: object): any[];\r\n    static hasKey(object: object, key: string): boolean;\r\n    static each(object: object, fn: (key: any, value: any, object: any) => (boolean | void)): void;\r\n    static toJson(object: any): any;\r\n    static parseJson(data: string): any;\r\n}\r\n"}}
